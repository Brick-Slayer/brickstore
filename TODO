TODO:
-----
 * wanted list mode: conditions+=n/a, colors+=n/a, price=maxprice, qty=minqty
 
 * autosave?

 * Edit-> Set Tiered Prices...

 * Lugnet "Set Lists" import


STUFF FOR QT4.1:
----------------

 * export as PDF
 * print-preview



 * export order status
   - alle $ fields (ausser total)
   - status
   - pmt. status
   - order no.
   - remark on order
 

 * new document widget
 
 QWidget
  Splitter
   QWidget*
    QTabBar
    <MyEditor>
   
 bei d&d -> overlay <MyEditor> with Trans QWidget
 
Enabled-/Icon-/TitleChange auf QWidget -> Tab anpassen 
QWidget delete -> Tab anpassen

 
class CMultiTabWidget : public QWidget {

    QPair<QTabBar *, int> tabPositionForWidget(QWidget *);
    

    friend class CMultiTabWidgetPrivate;
    
    CMultiTabWidgetPrivate *d;
};

class CMultiTabPage : public QWidget {
    QTabBar *m_tab;
    QList<QWidget *> m_items;
};

class CMultiTabDrop : public QWidget {
    CMultiTabDrop(CMultiTabWidget *mtw, int splitter_index);
    dragEvent()
};

class CMultiTabWidgetPrivate {
    QSplitter *m_split;
    QList<CMultiTabPage *> m_pages;

};


(Ov Filter         X)
| x Simple      |
|   Extended    |
 ---------------

(Ov Filter         X)
|   Simple      |
| x Extended    |
 ---------------

Color = == != <> ~ ~~ !~ ^ $ blue and Price = == < <= > >= > <> != 4.5

Color = blue and price < 4.5

all ~ brick

Model mit neuer Header Data:
   Role_DataType: string, int, double, date, image


On click --> open editor window

 v Advanced Filter \ > Order Details \ [||||| ] Matching sets \ [||    ] Set  to PriceGuide
 [xxxx v] [contains v] [_______________] (and) (or) X
 
 
 price contains xxx and all isn't 4
 
 xxxx   === all contains xxx
 
 
 FILTER := EXPR [LOGIC EXPR]
 LOGIC := AND | &&
       | OR | \|\|
 EXPR := FIELD COMP STR
       | STR
 FIELD := ... | ... | ...
 COMP := is | isn't | = | == | != | =! | contains | doesn't contain | does not contain | ~ | ~= | =~ | !~ | ~! | starts with | begins with | ends with | ^ | ^= | =^  | $ | $= | =$ | !^ | !$ | ^! | $!
" 
 STR := [a-zA-Z0-9 .,/()&[]-_*"'<>]+
 
 
 States:
 =======
 
 _START_ -> FILTER | STR | _END_
 
 FILTER -> COMP
 
 COMP -> STR
 
 STR -> _END_ | LOGIC
 
 LOGIC -> _START_
 
 
 
 Tokens in State:
 ================
 
_START_: <Field> | <trField>  --> COMP[field=yyval]
         .                    --> STR[field=All, comp=contains]
         ""                   --> END        
 
 is   : =|==
 isn't: !=|=!|<>

price less equal 4.5


class Filter {
public:
    enum ComparisonFlag {
        Matches     = 0x00,
        Is          = 0x01,
        Less        = 0x02,
        Greater     = 0x03,
        StartsWith  = 0x04,
        EndsWith    = 0x05,
        
        ComparisonCount = 6,
        
        Negated     = 0x80
    };
    
    enum Combination {
        And,
        Or,
        
        CombinationCount,
    };
    
    inline int field() const                { return m_field; }
    inline QString expression() const       { return m_expression; }
    inline Comparison comparison() const    { return m_comparison; }
    inline Combination combination() const  { return m_combination; }
    
    void setField(int field);
    void setEpression(const QString &expr);
    void setComparison(Comparsion cmp);
    void setCombination(Combination cmb);
    
private:
    int         m_field       : 16;
    Comparison  m_comparison  :  8;
    Combination m_combination :  8;
    QString     m_expression;
}

class FilterParser {
public:
    QList<Filter> parse(const QString &str);
    
private:
    void rebuildComparisonTokens();
    int matchField(int &pos, const QString &str);
    int matchCompare(int &pos, const QString &str);
    

    QHash<QString, int> m_comparison_tokens;
};
 


// find a filed name (english or translated) starting at position pos in the
// string str. If found, return the index and adjust pos tp point right to
// the position after the field name in str.
// If not found, return -1
int matchField(int &pos, const QString &str)
{
    return -1;
}

QList<Filter> FilterParser::parse(const QString &str)
{
    enum State {
        Start,
        Compare,
        Filter,
        Invalid
    };
    
    QList<Filter> filters;
    int pos = 0;
    Filter f;
    State state = Start;

    while (state != Invalid && pos < str.length()) {
        
        if (!eatWhiteSpace(pos, str))
            break;

        switch(state) {
        case Start:
            field = matchField(pos, str);

            if (field > -1) {
                f.field = field;
                state = Compare;
            }
            else
                state = Filter;
            break;
            
        case Compare:
            compare = matchCompare(pos, str)
        
            if (compare > -1) 
                f.compare = compare;
            state = Filter;
            break;
            
        case Filter:
            QPair<QString, int> res = matchFilterAndCombine(pos, str);
            
            f.filter = res.first;
            if (res.second > -1)
                f.combine = res.second;
            state = Start;
            break;
        }
    }
    return filters;
}

bool eatWhiteSpace(int &pos, const QString &str)
{
    int len = str.length();

    // eat ws
    while (pos < len && str[pos].isSpace())
        pos++;

    // empty or only ws
    return (pos != len)
}

int matchField(int &pos, const QString &str)
{
    int len = str.length();

    int found_field = -1;
    int found_len = -1;
        
    // find a matching field name - try both translated and untranslated
    // names. Also make sure to match the longest name (Qty vs . Qty.Diff.)
    for (int i = 0; i < cols && found == -1; ++i) {
        QString fstr_en = fieldName(i);
        int flen_en = fstr_en.length();
        QString fstr_tr = fieldNameTranslated(i);
        int flen_tr = fstr_tr.length();
        
        if (len - pos >= flen_en) {
            QStringRef sr(&str, pos, flen_en);
            if (fname_en == sr && found_len < flen_en) {
                found_field = i;
                found_len = flen_en;
            }
        }  
        if (len - pos >= flen_tr) {
            QStringRef sr(&str, pos, flen_tr);
            if (fname_tr == sr && found_len < flen_tr) {
                found_field = i;
                found_len = flen_tr;
            }
        }  
    }
    if (found_field != -1)
        pos += found_len;
    return found_field;
}

int matchCompare(int &pos, const QString &str)
{
    int len = str.length();
    
    
void FilterParser::rebuildComparisonTokens()
{
    struct token_table { 
        int          m_comparison;
        const char * m_symbols;
        const char * m_words;
    } predefined[] = {
        { Filter::Is,                           "=,==,===",         QT_TR_NOOP( "is,equals" ) },
        { Filter::Is | Filter::Negated,         "!=,=!,!==,==!,<>", QT_TR_NOOP( "is not,doesn't equal,does not equal" ) },
        { Filter::Less,                         "<",                QT_TR_NOOP( "less than" ) },
        { Filter::Greater | Filter::Negated,    "<=,=<",            QT_TR_NOOP( "less equal than" ) },
        { Filter::Greater,                      ">",                QT_TR_NOOP( "greater than" ) },
        { Filter::Less | Filter::Negated,       ">=,=>",            QT_TR_NOOP( "greater equal than" ) },
        { Filter::Matches,                      "~,~=,=~",          QT_TR_NOOP( "contains,matches" ) },
        { Filter::Matches | Filter::Negated,    "!~,~!,!~=,!=~",    QT_TR_NOOP( "doesn't contain,does not contain,doesn't match,does not match" ) },
        { Filter::StartsWith,                   "^,^=,=^",          QT_TR_NOOP( "starts with,begins with" ) },
        { Filter::StartsWith | Filter::Negated, "!^,^!=,!=^",       QT_TR_NOOP( "doesn't start with,does not start with,doesn't begin with,does not begin with" ) },
        { Filter::EndsWith,                     "$,$=,=$",          QT_TR_NOOP( "ends with" ) },
        { Filter::EndsWith | Filter::Negated,   "!$,$!=,!=$",       QT_TR_NOOP( "doesn't end with,does not end with" ) },
        
        { 0, 0, 0 }
    };
    
    m_comparison_tokens.clear();
    
    for (token_table *tt = predefined; tt->m_symbols || tt->m_words; ++tt) {
        foreach (QString symbol, QString::fromLatin1(tt->m_symbols).split(QLatin1Char(',')))
            m_comparison_tokens.insert(tt->m_comparison, symbol); 

        foreach (QString word, QString::fromLatin1(tt->m_words).split(QLatin1Char(',')))
            m_comparison_tokens.insert(tt->m_comparison, word);

        foreach (QString word, tr(QLatin1String(tt->m_words)).split(QLatin1Char(',')))
            m_comparison_tokens.insert(tt->m_comparison, word);
    }
}


 
COMP: =|==|!=|<>|<|>|<=|>=|=>|=<|~|~=|!~|~!|^|^=|^!|!^|$|!$|$!    --> STR[comp=yyval]
      .*  --> _ERROR_
 
 
 COMB := && || & |
 
sl = str.simplified().split(' ');

QList<Filters> fl;
while(true) {
    Filter f;
    if (int field = matchesField(sl[0])) {
        f.field = field;
    
        if (int compare = matchesCompare(sl[1]))
    }
    else {
        f.field = All;
        f.comparse = Contains;
    }
    
        
STR: .+ bis zu (and|or|tr(and)|tr(or)|&|&&|'|'|'||')
 
 
 QList<Filter> parseFilter(const QString &_str)
 {
    QString str = _str.simplified();
 }
 
 
 if (fieldlist.find(section(0)) && verblist.find(section(1))
    extended = true;
    
    
  if (extended) {
    splitat whitespace with " 
    
    QString str = text().simplified();
    
    QString field = str.section(QLatin1Char(' '), 0, -1, QString::SectionSkipEmpty);
  
    if (fieldlist.contains(field) && field.length() < str.length()) {
        int start = field.length() + 1;
        int len = str.length() - start;
        
        QString verbmatch;
        
        foreach (QString verb, verblist) {
            int verblen = verb.length();
            
            if (verblen < len) {
                QStringRef sub (&str, start, verblen);
                if (sub == verb && verb.length() > verbmatch.length())
                    verbmatch = verb;
        }
        
        if (!verbmatch.isEmpty())
            extended = true;      
    }
  
    
    QStringList sl = str.simplified().split(QLatin1Char(' '), QString::SkipEmptyParts);
    
    if (sl.count() >= 3) {
        if (fieldlist.contains(sl[0])) {
        
        
        }
    }
 
 is / isn't / is not / begins with / contains ends with / does not / contain doesn't contain



algo:

enum {
    Start,
    ParseField,
    ParseComparison,
    ParseField,
    ParseCombination
}

state = Start;
str = "";

while (token = nextToken()) {
    if (state == Start) {
        str += token;    
    
        int col = column(str);
        
        if (col >= 0) {
        ...
        }    
    }

} 

if (state == Start) {
    type = Simple;
    regex = QRegExp(str);
}



Label: [xxx]

Filter: [      v]
Set Matching: [||||||  ]

int id = MySB->addWidgetSection(QString, QWidget)
int id = MySB->addInfoSection(QString, bool clickable)


Weight   P
Total    P
Lots     P
Items    P
Errors   P? A? -> go to next error  Errors: 5 (<)(>)
SetToPG  P [|||  ] (x)
Matching P? A? -> Cancel  Matching [|||| ] (x)
Order    A   Order: Robert Griebl (V)
Filter   A   Filter:  [_________X] (V)


Name:
Type: Label | Clickable | Progress | CancelButton | Prev | Next | More



enum SectionFlags {
    Collapsible, Expanding
};



class InfoBar : public QWidget
{
    Q_OBJECT
    
public:
    InfoBar(QWidget *parent = 0);
    
    enum ButtonType {
        Cancel,
        Previous,
        Next,
        More,
        
        Count
    };
    
    int addSection(const QString &title = QString());
    int insertSection(int before, const QString &title = QString());
    void removeSection(int section);
    
    QLabel *sectionTitel(int section);
    QAbstractButton *sectionButton(int section, ButtonType button);
    QWidget *sectionContent(int section);
    void setSectionContent(int section, QWidget *w);
    
private:
    class InfoBarPrivate;

    QScopedPointer<InfoBarPrivate> d;
}

struct Section {
    int                     id;
    QWidget *               widget;
    QLabel *                label;
    QWidget *               content;
    QAbstractButton[Count] *buttons;
};

struct InfoBarPrivate
{
    QList<InfoSection *> sections;
    static int           sectionIds;
};

int InfoBarPrivate::sectionIds = 0;

InfoBar::InfoBar(QWidget *parent)
    : QWidget(parent), d(new InfoBarPrivate)
{
}

int InfoBar::insertSection(int before, const QString &title)
{
    Section *s = new Section;
    s->id = ++d->sectionIds;
    s->label = new QLabel(title, this);
    s->content = 0;
    memset(s->buttons, 0, sizeof(s->buttons));
    
    d->sections.append(s);
    
    return s->id;
}

int InfoBar::addSection(const QString &title)
{
    return insertSection(d->sections.count(), title);    
}

void InfoBar::removeSection(int id)
{
    for (int i = 0; i < d->sections.count(); ++i) {
        Section *s = d->sections.at(i);
        
        if (s->id == id) {
            delete s->widget;
            d->sections.removeAt(i);
        }
    }
}


class DocumentStatus {

  QAbstractButton *createButton(const QString &);
  QAbstractButton *createButton(const QIcon &);
  
    enum Button {
        None,
        More,
        Cancel,
        Prev,
        Next,
        Info
    };
    
   Q_DECLARE_FLAGS(Button, Buttons)
  
  int addSection(const QString &label, QWidget *content, Buttons b = None);
  void setSectionLabel()
  void setSectionWidget();
  void setSectionHighlight(bool on, const QColor &col);
  
  QWiddget *sectionWidget();

    struct Section {
        QLabel *m_label;
        QWidgt m_widget;
        QAbstractButton[Info] *m_buttons;
    };
}

